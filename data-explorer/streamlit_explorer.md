# Graphiti Knowledge Graph Explorer

## Overview

The **Graphiti Knowledge Graph Explorer** is a comprehensive Streamlit web application designed to visualize, explore, and analyze knowledge graphs stored in Neo4j databases. This tool serves as a powerful interface for understanding the relationships, entities, and episodic data generated by the Graphiti MCP (Model Context Protocol) server.

## Application Purpose

The explorer bridges the gap between raw graph data and human understanding by providing:
- **Visual exploration** of complex knowledge networks
- **Interactive search** across all graph entities and properties  
- **Relationship analysis** to understand entity connections
- **Episodic data browsing** for conversational context
- **Real-time statistics** and health monitoring

## Database Schema Analysis

Based on exploration of the current Neo4j instance, the application works with the following data model:

### Node Types
- **Entity** (Primary knowledge objects)
  - `name`: Entity identifier (e.g., "–ê–ª–µ–∫—Å–µ–π", "CTO", "—Å—Ç–∞—Ä—Ç–∞–ø Centrion.ai")
  - `entity_type`: Classification (may be null)
  - `summary`: Detailed description with context
  - `uuid`: Unique identifier
  - `created_at`: Timestamp

- **Episodic** (Conversational memory chunks)
  - `name`: Episode identifier
  - `source`: Origin of data (e.g., "message") 
  - `content`: Full episodic content/conversation
  - `created_at`: Timestamp
  - `group_id`: Episode grouping

- **Community** (Entity clusters)
  - `name`: Community identifier
  - `summary`: Community description

### Relationship Types
- **MENTIONS** (55 relationships): References between entities and episodes
- **RELATES_TO** (44 relationships): Semantic connections between entities
- **HAS_MEMBER**: Community membership relationships

### Data Characteristics
- **Total Nodes**: 55 (as of current database state)
- **Content Languages**: Supports multilingual content (Russian/Ukrainian/English observed)
- **Content Types**: Personal profiles, professional information, psychological assessments
- **Relationship Density**: High interconnectivity with entities mentioned across multiple episodes

## Feature Documentation

### 1. Database Connection Management
**Location**: Sidebar interface
**Purpose**: Secure connection to Neo4j instances

**Features**:
- Environment variable auto-detection (`NEO4J_URI`, `NEO4J_USER`, `NEO4J_PASSWORD`)
- Connection testing with immediate feedback
- Default fallbacks for local development (`bolt://localhost:7687`, `neo4j/demodemo`)
- Session persistence across app interactions

**Technical Implementation**:
- Robust error handling with detailed error messages
- Connection pooling through Neo4j driver
- Graceful handling of network timeouts and authentication failures

### 2. Overview Dashboard (üìä Tab)
**Purpose**: High-level database health and composition analysis

**Metrics Displayed**:
- **Total Nodes**: Real-time count of all graph nodes
- **Total Relationships**: Count of all connections
- **Node Types**: Number of distinct label types
- **Relationship Types**: Number of distinct relationship categories

**Visualizations**:
- **Pie Chart**: Node type distribution for understanding data composition
- **Bar Chart**: Relationship type frequency for connection pattern analysis

**Technical Features**:
- Async data loading with progress indicators
- Automatic refresh on database changes
- Graceful handling of empty databases
- Error state management with actionable feedback

### 3. Entity Search (üîç Tab)
**Purpose**: Comprehensive entity discovery and exploration

**Search Capabilities**:
- **Full-text search** across all entity properties
- **Case-insensitive** matching for user convenience
- **Configurable result limits** (5-50 results)
- **Multi-property matching** (name, type, summary, custom fields)

**Result Presentation**:
- **Expandable cards** for detailed entity inspection
- **Property tables** with all entity attributes
- **Label display** showing entity classifications
- **Timestamp information** for temporal context
- **Relationship quick-access** buttons for navigation

**Empty State Handling**:
- Clear guidance on adding data via MCP server
- Instructions for Claude Desktop integration
- Helpful onboarding for new users

### 4. Graph Visualization (üåê Tab)
**Purpose**: Interactive network visualization of knowledge relationships

**Visualization Engine**:
- **NetworkX** for graph layout algorithms
- **Plotly** for interactive web-based rendering
- **Spring layout** algorithm for optimal node positioning
- **Zoom and pan** capabilities for large graphs

**Customization Options**:
- **Node limit slider** (10-200 nodes) for performance management
- **Episode inclusion toggle** for filtering data types
- **Color coding** by node type for visual distinction
- **Hover information** showing node details

**Technical Optimizations**:
- **Lazy loading** for large datasets
- **Viewport optimization** for smooth interactions
- **Memory management** for browser stability
- **Responsive design** for various screen sizes

### 5. Episode Browser (üìù Tab)
**Purpose**: Exploration of conversational and episodic memory

**Content Display**:
- **Chronological ordering** with newest episodes first
- **Content preview** with truncation for readability
- **Metadata display** (source, group, timestamps)
- **Expandable interface** for full content access

**Filtering and Pagination**:
- **Configurable limits** (5-50 episodes)
- **Source filtering** capabilities
- **Group-based organization**

**Empty State Management**:
- **Educational content** explaining episode creation
- **Integration instructions** for MCP server
- **Expected data flow documentation**

### 6. Relationship Analysis (üîó Tab)
**Purpose**: Deep-dive into entity connections and relationship patterns

**Analysis Features**:
- **Entity relationship mapping** with visual indicators
- **Bidirectional relationship display**
- **Relationship type categorization**
- **Property inspection** for both nodes and edges

**Interactive Elements**:
- **Expandable relationship details**
- **JSON property viewers** with formatting
- **Navigation between connected entities**
- **Relationship strength indicators**

## Technical Architecture

### Application Structure
```
streamlit_explorer.py
‚îú‚îÄ‚îÄ GraphitiExplorer (Main class)
‚îÇ   ‚îú‚îÄ‚îÄ Connection management
‚îÇ   ‚îú‚îÄ‚îÄ Query execution
‚îÇ   ‚îî‚îÄ‚îÄ Data retrieval methods
‚îú‚îÄ‚îÄ Helper Functions
‚îÇ   ‚îú‚îÄ‚îÄ create_connection()
‚îÇ   ‚îú‚îÄ‚îÄ safe_query()
‚îÇ   ‚îî‚îÄ‚îÄ get_database_stats()
‚îú‚îÄ‚îÄ UI Components
‚îÇ   ‚îú‚îÄ‚îÄ show_overview()
‚îÇ   ‚îú‚îÄ‚îÄ show_search()
‚îÇ   ‚îú‚îÄ‚îÄ show_graph_view()
‚îÇ   ‚îú‚îÄ‚îÄ show_episodes()
‚îÇ   ‚îî‚îÄ‚îÄ show_relationships()
‚îî‚îÄ‚îÄ Main Application (main())
```

### Key Technical Decisions

#### 1. Error Handling Strategy
**Decision**: Comprehensive error wrapping with user-friendly messages
**Rationale**: Neo4j queries can fail for various reasons (connection, syntax, data). Users need clear feedback without technical jargon.
**Implementation**: `safe_query()` function wraps all database interactions with logging and error translation.

#### 2. Database Connection Management
**Decision**: Session-based connection with connection testing
**Rationale**: Streamlit apps can have long-lived sessions. Connection health must be monitored.
**Implementation**: Connection testing on establishment, graceful degradation on failures.

#### 3. Query Optimization
**Decision**: Parameterized queries with result limits
**Rationale**: Prevents SQL injection, manages memory usage, ensures responsive UI.
**Implementation**: All queries use parameters, configurable limits with sensible defaults.

#### 4. Data Visualization Approach
**Decision**: Client-side rendering with Plotly
**Rationale**: Interactive capabilities, responsive design, no server-side rendering overhead.
**Implementation**: NetworkX for layout computation, Plotly for rendering, progressive loading.

#### 5. State Management
**Decision**: Streamlit session state for connection persistence
**Rationale**: Users shouldn't re-authenticate on every interaction.
**Implementation**: `st.session_state` for connection objects and cached data.

#### 6. Responsive UI Design
**Decision**: CSS Grid and Flexbox with custom styling
**Rationale**: Professional appearance, mobile compatibility, accessibility.
**Implementation**: Custom CSS with Streamlit's markdown injection.

### Performance Considerations

#### Database Query Performance
- **Index Usage**: Queries designed to leverage Neo4j's label and property indices
- **Result Limiting**: All queries include `LIMIT` clauses to prevent memory overflow
- **Parameter Binding**: Prevents query recompilation and improves execution plans

#### Client-Side Performance
- **Lazy Loading**: Large datasets loaded on-demand
- **Progressive Rendering**: UI updates incrementally for large result sets
- **Memory Management**: Explicit cleanup of large objects

#### Network Optimization
- **Connection Pooling**: Neo4j driver handles connection reuse
- **Batch Operations**: Multiple related queries combined where possible
- **Async Operations**: Non-blocking UI updates during data loading

### Extensibility Features

#### Pluggable Visualizations
The architecture supports additional visualization types:
- Timeline views for temporal data
- Hierarchical displays for taxonomies
- Custom layouts for specific domains

#### Query Customization
The `GraphitiExplorer` class can be extended with:
- Domain-specific query methods
- Custom aggregation functions
- Specialized relationship analysis

#### UI Component Modularity
Each tab is implemented as a separate function, enabling:
- Easy addition of new analysis views
- A/B testing of different interfaces
- Custom dashboards for specific use cases

## Usage Instructions

### Initial Setup
1. **Start Neo4j**: Ensure Neo4j database is running on `bolt://localhost:7687`
2. **Install Dependencies**: `pip install -r requirements_streamlit.txt`
3. **Launch Application**: `streamlit run streamlit_explorer.py`
4. **Access Interface**: Navigate to `http://localhost:8501`

### Connection Configuration
1. **Default Connection**: Uses environment variables or localhost defaults
2. **Custom Connection**: Update URI, username, password in sidebar
3. **Test Connection**: Click "Connect" button for validation
4. **Connection Status**: Sidebar shows green checkmark when connected

### Data Exploration Workflow
1. **Overview First**: Check database health and composition
2. **Search Entities**: Find specific entities or browse by type
3. **Visualize Relationships**: Use graph view to understand connections
4. **Browse Episodes**: Read conversational context and memory
5. **Analyze Relationships**: Deep-dive into specific entity connections

### Best Practices
- **Start Small**: Use low node limits for initial graph visualization
- **Filter Appropriately**: Include/exclude episodes based on analysis needs
- **Search Strategically**: Use specific terms for faster results
- **Monitor Performance**: Watch for slow queries with large datasets

## Integration with Graphiti Ecosystem

### MCP Server Integration
The explorer is designed to work seamlessly with Graphiti MCP server:
- **Real-time Updates**: Database changes from MCP server immediately visible
- **Schema Compatibility**: Handles all Graphiti node and relationship types
- **Multilingual Support**: Processes content in various languages

### Claude Desktop Workflow
Typical usage pattern:
1. **Conversation in Claude**: Generate entities and relationships via MCP
2. **Immediate Exploration**: Switch to Streamlit to visualize new data
3. **Iterative Analysis**: Use insights to guide further conversation
4. **Knowledge Validation**: Verify MCP server is creating expected structures

### Development and Debugging
The explorer serves as a debugging tool for:
- **MCP Server Output**: Verifying correct entity creation
- **Relationship Accuracy**: Checking semantic connections
- **Data Quality**: Identifying missing or incorrect properties
- **Performance Issues**: Monitoring query execution times

## Future Enhancement Opportunities

### Advanced Analytics
- **Community Detection**: Automatic entity clustering
- **Temporal Analysis**: Timeline views of knowledge evolution
- **Centrality Metrics**: Identify key entities in the graph
- **Similarity Scoring**: Find related entities by content

### Export and Integration
- **Data Export**: CSV, JSON, GraphML format support
- **Visualization Export**: Save graphs as images or PDFs
- **API Endpoints**: REST API for programmatic access
- **Webhook Integration**: Real-time notifications of graph changes

### User Experience Enhancements
- **Saved Searches**: Bookmark frequent queries
- **Custom Dashboards**: User-defined view configurations
- **Collaboration Features**: Share specific views with team members
- **Mobile Optimization**: Enhanced responsive design

### Performance Optimizations
- **Caching Layer**: Redis integration for query results
- **Streaming Updates**: WebSocket connections for real-time data
- **Parallel Processing**: Concurrent query execution
- **Index Recommendations**: Automatic Neo4j index suggestions

## Conclusion

The Graphiti Knowledge Graph Explorer provides a comprehensive interface for understanding and analyzing knowledge graphs generated by AI conversations. Its robust architecture, comprehensive error handling, and intuitive interface make it an essential tool for working with Graphiti-powered knowledge systems. The application successfully bridges the gap between raw graph data and actionable insights, enabling users to explore, understand, and leverage their AI-generated knowledge networks effectively.
